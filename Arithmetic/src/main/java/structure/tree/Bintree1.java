package structure.tree;import java.util.ArrayList;import java.util.List;public class Bintree1 {//一个此类 就是一个树节点    public Bintree1 left;    public Bintree1 right;    public Bintree1 root;    //    数据域    private Object  data;    //    存节点    public List<Bintree1> datas;    public Bintree1(Bintree1 left, Bintree1 right, Object data){//构造方法 初始化当前节点        this.left=left;        this.right=right;        this.data=data;    }    //    将初始的左右孩子值为空    public Bintree1(Object data){           // 另一个构造方法        this(null,null,data);    }    public Bintree1() {    }    public void creat(Object[] objs){//建立树        datas=new ArrayList<Bintree1>();        for(Object o:objs){            datas.add(new Bintree1(o));      //      将一个数组的值依次转换为Node节点        }        root=datas.get(0);//        第一个数为根节点        for (int i = 0; i <objs.length/2; i++) {//        建立二叉树            datas.get(i).left=datas.get(i*2+1);//            左孩子            if(i*2+2<datas.size()){//避免偶数的时候 下标越界                datas.get(i).right=datas.get(i*2+2);//            右孩子            }        }    }    //先序遍历   根左右    public void preorder(Bintree1 root){        if(root!=null){            System.out.println(root.data);//当前节点即是 当前小子树的父节点            preorder(root.left);            preorder(root.right);        }    }    //中序遍历 左根右    public void inorder(Bintree1 root){        if(root!=null){            inorder(root.left);            System.out.println(root.data);//当前节点即是 当前小子树的父节点            inorder(root.right);        }    }    //后序遍历 左右根    public void afterorder(Bintree1 root){        if(root!=null){            afterorder(root.left);            afterorder(root.right);            System.out.println(root.data);//当前节点即是 当前小子树的父节点        }    }    public static void main(String[] args) {//先序遍历        Bintree1 Bintree1=new Bintree1();        Object []a={2,4,5,7,1,6,12,32,51,22};        Bintree1.creat(a);        Bintree1.preorder(Bintree1.root);    }}